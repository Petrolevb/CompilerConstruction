-- automatically generated by BNF Converter
module Main where


import System.IO ( stdin, hGetContents )
import System.Environment ( getArgs, getProgName )

import LexJavalette
import ParJavalette
import SkelJavalette
import PrintJavalette
import AbsJavalette

import AnnotatedAbs
import TypeChecker

import Generator

import Llvm

import ErrM

data Compilation = Jvm | Llvm | X86
type ParseFun a = [Token] -> Err a

type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = if v > 1 then putStrLn s else return ()

runFile :: Compilation -> Verbosity -> ParseFun Program -> String -> IO ()
runFile c v p f = putStrLn f >> readFile f >>= run c v p f

run :: Compilation -> Verbosity -> ParseFun Program -> String -> String -> IO ()
run c v p fileName s = 
    case p (myLexer s) of
           Bad s    -> do putStrLn "\nParse              Failed...\n"
                          putStrLn s
           Ok  tree -> case typecheck tree of
                            Bad s  -> do
                                ioError (userError "ERROR")
                                putStrV v $ "\nFail to anotate : " ++ s 
                            Ok at  -> do
                                case c of 
                                    Llvm -> generationLlvm at fileName
                                    Jvm -> generationJvm at fileName
                                ioError (userError "OK")

main :: IO ()
main = do args <- getArgs
          case args of
            [] -> hGetContents stdin >>= run Jvm 2 pProgram "genFile.jl"
            "-s":fs -> mapM_ (runFile Jvm 0 pProgram) fs
            "-b":"JVM":fs  -> mapM_ (runFile Jvm 2 pProgram) fs 
            "-b":"LLVM":fs -> mapM_ (runFile Llvm 2 pProgram) fs
            fs -> mapM_ (runFile Jvm 2 pProgram) fs


